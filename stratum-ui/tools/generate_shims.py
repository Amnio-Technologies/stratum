#!/usr/bin/env python3
import re
import sys
from pathlib import Path
import io

# Ensure UTF-8 stdout
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")

# Paths (adjust if your files live elsewhere)
INCLUDE_FOLDER = Path("include")
WIDGET_LIST_H = INCLUDE_FOLDER / "lvlens_widget_list.h"
SHIMS_H = INCLUDE_FOLDER / "lvlens_shims.h"
LV_CONF_H = INCLUDE_FOLDER / "lv_conf.h"

print(f"Reading widget list from: {WIDGET_LIST_H}", file=sys.stderr)

# 1) Read lv_conf.h (if it exists) and collect enabled LV_USE_<WIDGET> flags.
enabled_macros = set()
if LV_CONF_H.exists():
    conf_text = LV_CONF_H.read_text(encoding="utf-8", errors="ignore")
    for m in re.finditer(
        r"^\s*#\s*define\s+(LV_USE_[A-Z0-9_]+)\s+([0-9]+)", conf_text, re.MULTILINE
    ):
        macro, val = m.group(1), int(m.group(2))
        if val != 0:
            enabled_macros.add(macro)
else:
    print(
        f"Warning: {LV_CONF_H} not found. Assuming all widgets enabled.",
        file=sys.stderr,
    )


def alias_to_macro(alias: str) -> str:
    core = alias[len("lv_") : -len("_create")]
    return f"LV_USE_{core.upper()}"


# 2) Parse widget list with X and Y entries
entries = []
x_pat = re.compile(r"^\s*X\(\s*(lv_[A-Za-z0-9_]+_create)\s*\)")
y_pat = re.compile(
    r"^\s*Y\(\s*(lv_[A-Za-z0-9_]+_create)\s*,\s*(lv_[A-Za-z0-9_]+_create)\s*\)"
)

if not WIDGET_LIST_H.exists():
    print(f"Error: Cannot find {WIDGET_LIST_H}", file=sys.stderr)
    sys.exit(1)

with WIDGET_LIST_H.open("r", encoding="utf-8", errors="ignore") as f:
    for line in f:
        m = x_pat.match(line)
        if m:
            fn = m.group(1)
            entries.append((fn, fn))
            continue
        m2 = y_pat.match(line)
        if m2:
            alias, real = m2.group(1), m2.group(2)
            entries.append((alias, real))

if not entries:
    print(
        f"Error: No X(...) or Y(...) entries found in {WIDGET_LIST_H}", file=sys.stderr
    )
    sys.exit(1)

# 3) Filter by lv_conf.h, but always include lv_obj_create unconditionally
enabled_entries = []
for alias, real in entries:
    if alias == "lv_obj_create":
        enabled_entries.append((alias, real))
        continue

    macro = alias_to_macro(alias)
    if LV_CONF_H.exists():
        if macro in enabled_macros:
            enabled_entries.append((alias, real))
    else:
        enabled_entries.append((alias, real))

print(f"Enabled entries: {len(enabled_entries)} of {len(entries)}", file=sys.stderr)

# 4) Generate lvlens_shims.h
lines = []
lines.append("#pragma once\n")
lines.append("// Auto-generated by generate_shims.py\n")
lines.append('#include "lvlens_registry.h"')
lines.append("#include <lvgl.h>\n")

# Undef aliases
lines.append("// 1) Undefine alias macros")
for alias, real in enabled_entries:
    lines.append(f"#ifdef {alias}")
    lines.append(f"#undef {alias}")
    lines.append("#endif")
lines.append("")

# Raw + hook for real names
lines.append("// 2) Raw helpers and hook wrappers for real functions")
for alias, real in enabled_entries:
    lines.append(f"static inline lv_obj_t *lvlens_{real}_raw(lv_obj_t *parent) {{")
    lines.append(f"    return {real}(parent);")
    lines.append("}")
    lines.append("")
    lines.append(
        f"static inline lv_obj_t *lvlens_{real}(lv_obj_t *parent, const char *file, int line) {{"
    )
    lines.append(f"    lv_obj_t *obj = lvlens_{real}_raw(parent);")
    lines.append(f'    lvlens_register(obj, file, line, "{alias}");')
    lines.append("    return obj;")
    lines.append("}\n")

# Redirect real and alias to hook
lines.append("// 3) Redirect both real and alias names")
for alias, real in enabled_entries:
    lines.append(f"#define {real}(parent) \\")
    lines.append(f"    lvlens_{real}((parent), __FILE__, __LINE__)\n")
    if alias != real:
        lines.append(f"#define {alias}(parent) \\")
        lines.append(f"    lvlens_{real}((parent), __FILE__, __LINE__)\n")

INCLUDE_FOLDER.mkdir(parents=True, exist_ok=True)
with SHIMS_H.open("w", encoding="utf-8") as f:
    f.write("\n".join(lines))

print(f"Generated {SHIMS_H} with {len(enabled_entries)} entries.", file=sys.stderr)
