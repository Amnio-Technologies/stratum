#!/usr/bin/env python3
import re
import sys
import json
import hashlib
from pathlib import Path
import io
import argparse

# Ensure UTF-8 stdout
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")

parser = argparse.ArgumentParser(description="Generate lvlens_shims.h")
parser.add_argument(
    "--no-cache",
    action="store_true",
    dest="no_cache",
    help="Ignore cache and always regenerate shims",
)
args = parser.parse_args()

# Paths (adjust if your files live elsewhere)
INCLUDE_FOLDER = Path("include")
WIDGET_LIST_H = INCLUDE_FOLDER / "lvlens_widget_list.h"
SHIMS_H = INCLUDE_FOLDER / "lvlens_shims.h"
LV_CONF_H = INCLUDE_FOLDER / "lv_conf.h"
CACHE_FILE = SHIMS_H.with_suffix(".cache.json")


def compute_inputs_hash():
    """Hash contents of widget list + lv_conf (if present)."""
    hasher = hashlib.sha256()
    hasher.update(WIDGET_LIST_H.read_bytes())
    if LV_CONF_H.exists():
        hasher.update(LV_CONF_H.read_bytes())
    return hasher.hexdigest()


def load_cached_hash():
    """Read the stored inputs_hash, or None if missing/invalid."""
    if not CACHE_FILE.exists():
        return None
    try:
        data = json.loads(CACHE_FILE.read_text(encoding="utf-8"))
        return data.get("inputs_hash")
    except Exception:
        return None


def save_cached_hash(h):
    """Write out the new inputs_hash."""
    CACHE_FILE.write_text(json.dumps({"inputs_hash": h}), encoding="utf-8")


# 0) CACHE CHECK
current_hash = compute_inputs_hash()
if not args.no_cache and load_cached_hash() == current_hash:
    print("âœ¨ No changes detected; skipping shim generation.", file=sys.stderr)
    sys.exit(0)

print(f"Reading widget list from: {WIDGET_LIST_H}", file=sys.stderr)

# 1) Read lv_conf.h and gather enabled LV_USE_* flags
enabled_macros = set()
if LV_CONF_H.exists():
    conf_text = LV_CONF_H.read_text(encoding="utf-8", errors="ignore")
    for m in re.finditer(
        r"^\s*#\s*define\s+(LV_USE_[A-Z0-9_]+)\s+([0-9]+)", conf_text, re.MULTILINE
    ):
        macro, val = m.group(1), int(m.group(2))
        if val:
            enabled_macros.add(macro)
else:
    print(
        f"Warning: {LV_CONF_H} not found; assuming all widgets enabled.",
        file=sys.stderr,
    )


def alias_to_macro(alias: str) -> str:
    core = alias[len("lv_") : -len("_create")]
    return f"LV_USE_{core.upper()}"


# 2) Parse widget list (X(alias)==real, Y(alias,real) for shims/aliases)
entries = []
x_pat = re.compile(r"^\s*X\(\s*(lv_[A-Za-z0-9_]+_create)\s*\)")
y_pat = re.compile(
    r"^\s*Y\(\s*(lv_[A-Za-z0-9_]+_create)\s*,\s*(lv_[A-Za-z0-9_]+_create)\s*\)"
)

if not WIDGET_LIST_H.exists():
    print(f"Error: Cannot find {WIDGET_LIST_H}", file=sys.stderr)
    sys.exit(1)

with WIDGET_LIST_H.open("r", encoding="utf-8", errors="ignore") as f:
    for line in f:
        m = x_pat.match(line)
        if m:
            entries.append((m.group(1), m.group(1)))
            continue
        m2 = y_pat.match(line)
        if m2:
            entries.append((m2.group(1), m2.group(2)))

if not entries:
    print(
        f"Error: No X(...) or Y(...) entries found in {WIDGET_LIST_H}", file=sys.stderr
    )
    sys.exit(1)

# 3) Filter by lv_conf.h, but always include lv_obj_create
enabled_entries = []
for alias, real in entries:
    if alias == "lv_obj_create":
        enabled_entries.append((alias, real))
        continue
    macro = alias_to_macro(alias)
    if LV_CONF_H.exists():
        if macro in enabled_macros:
            enabled_entries.append((alias, real))
    else:
        enabled_entries.append((alias, real))

print(f"Enabled entries: {len(enabled_entries)} of {len(entries)}", file=sys.stderr)

# 4) Generate lvlens_shims.h
lines = [
    "#pragma once\n",
    "// Auto-generated by generate_shims.py\n",
    '#include "lvlens_registry.h"',
    "#include <lvgl.h>\n",
    "// 1) Undefine alias macros",
]
for alias, _ in enabled_entries:
    lines += [f"#ifdef {alias}", f"#undef {alias}", "#endif"]
lines.append("")

lines.append("// 2) Raw helpers and hook wrappers for real functions")
for alias, real in enabled_entries:
    lines += [
        f"static inline lv_obj_t *lvlens_{real}_raw(lv_obj_t *parent) {{",
        f"    return {real}(parent);",
        "}",
        "",
        f"static inline lv_obj_t *lvlens_{real}(lv_obj_t *parent, const char *file, int line) {{",
        f"    lv_obj_t *obj = lvlens_{real}_raw(parent);",
        f'    lvlens_register(obj, file, line, "{alias}");',
        "    return obj;",
        "}\n",
    ]

lines.append("// 3) Redirect both real and alias names")
for alias, real in enabled_entries:
    lines += [
        f"#define {real}(parent) \\",
        f"    lvlens_{real}((parent), __FILE__, __LINE__)\n",
    ]
    if alias != real:
        lines += [
            f"#define {alias}(parent) \\",
            f"    lvlens_{real}((parent), __FILE__, __LINE__)\n",
        ]

INCLUDE_FOLDER.mkdir(parents=True, exist_ok=True)
SHIMS_H.write_text("\n".join(lines), encoding="utf-8")

# 5) Update cache
save_cached_hash(current_hash)

print(f"Generated {SHIMS_H} with {len(enabled_entries)} entries.", file=sys.stderr)
